// Code generated by protoc-gen-mgorm. DO NOT EDIT.
package idgen

import (
	"context"
	"fmt"
	"time"

	"github.com/995933447/mgorm"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

const (
	IdSegmentDbName   = "idgen"
	IdSegmentTbName   = "id_segment"
	IdSegmentConnName = "idgen"
)

// 索引
var idSegmentIndexKeys = []string{}

var idSegmentUniqueIndexKeys = []string{
	"tb_name",
}

var idSegmentExpireIndexKeys = []string{}

type IdSegmentOrm struct {
	ID        primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	TbName    string             `json:"tb_name" bson:"tb_name"`
	MaxId     uint64             `json:"max_id" bson:"max_id"`
	Step      uint64             `json:"step" bson:"step"`
	Remark    string             `json:"remark" bson:"remark"`
	CreatedAt time.Time          `json:"created_at,omitempty" bson:"created_at,omitempty"`
	UpdatedAt time.Time          `json:"updated_at,omitempty" bson:"updated_at,omitempty"`
}

var idSegmentOrmCache mgorm.Cache

func SetIdSegmentOrmCache(cache mgorm.Cache) {
	idSegmentOrmCache = cache
}

var onIdSegmentOrmQueryDone mgorm.OnQueryDoneFunc

func SetIdSegmentOrmOnQueryDone(fn mgorm.OnQueryDoneFunc) {
	onIdSegmentOrmQueryDone = fn
}

func NewIdSegmentModel() *IdSegmentModel {
	cache := idSegmentOrmCache
	if cache == nil {
		cache = mgorm.DefaultCache
	}
	orm := mgorm.NewOrm(
		IdSegmentConnName,
		IdSegmentDbName,
		IdSegmentTbName,
		false,
		cache,
		idSegmentIndexKeys,
		idSegmentUniqueIndexKeys,
		idSegmentExpireIndexKeys,
	)
	onQueryDoneFunc := onIdSegmentOrmQueryDone
	if onQueryDoneFunc == nil {
		onQueryDoneFunc = mgorm.OnQueryDone
	}
	orm.SetOnQueryDone(onQueryDoneFunc)
	return &IdSegmentModel{
		Model: mgorm.Model[IdSegmentOrm]{
			Orm:    orm,
			Cached: false,
		},
	}
}

type IdSegmentModel struct {
	mgorm.Model[IdSegmentOrm]
}

func (m *IdSegmentModel) NormalizeOrmForInsert(data *IdSegmentOrm) {
	if data.ID.IsZero() {
		data.ID = primitive.NewObjectID()
	}
	if data.CreatedAt.IsZero() {
		data.CreatedAt = time.Now()
	}
	data.UpdatedAt = data.CreatedAt
}

func (m *IdSegmentModel) InsertOneIgnoreConflict(ctx context.Context, data *IdSegmentOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOneIgnoreConflict(ctx, data)
	return err
}

func (m *IdSegmentModel) InsertOne(ctx context.Context, data *IdSegmentOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOne(ctx, data)
	return err
}

func (m *IdSegmentModel) InsertMany(ctx context.Context, dataList []*IdSegmentOrm) error {
	var ins []any
	for _, data := range dataList {
		m.NormalizeOrmForInsert(data)
		ins = append(ins, data)
	}
	_, err := m.Model.InsertMany(ctx, ins)
	return err
}

func (m *IdSegmentModel) GetCacheKeys(data *IdSegmentOrm) []string {
	var cacheKeys []string
	cacheKeys = append(cacheKeys, fmt.Sprintf("_id:%s", data.ID.Hex()))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"tb_name:%s", data.TbName,
	))
	return cacheKeys
}

func (m *IdSegmentModel) Update(ctx context.Context, data *IdSegmentOrm) (*mongo.UpdateResult, error) {
	dataB, err := mgorm.ToBsonM(data)
	if err != nil {
		return nil, err
	}
	dataB["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": dataB["_id"]}, bson.M{"$set": dataB})
}

func (m *IdSegmentModel) UpdateOne(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": data})
}

func (m *IdSegmentModel) UpdateMany(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	data["updated_at"] = time.Now()
	return m.Model.UpdateMany(ctx, filter, bson.M{"$set": data})
}

func (m *IdSegmentModel) Upsert(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$setOnInsert": insertData})
}

func (m *IdSegmentModel) UpInc(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$inc": data, "$set": bson.M{"updated_at": time.Now()}, "$setOnInsert": insertData})
}

func (m *IdSegmentModel) UpAndInc(ctx context.Context, filter any, data, incdata bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$inc": incdata, "$setOnInsert": insertData})
}

func (m *IdSegmentModel) DeleteOne(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	return m.Model.DeleteOne(ctx, filter)
}

func (m *IdSegmentModel) DeleteMany(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	return m.Model.DeleteMany(ctx, filter)
}

func (m *IdSegmentModel) UpdateOneByID(ctx context.Context, id string, data bson.M) (*mongo.UpdateResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": objId}, bson.M{"$set": data})
}

func (m *IdSegmentModel) DeleteOneByID(ctx context.Context, id string) (*mongo.DeleteResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	return m.Model.DeleteOne(ctx, bson.M{"_id": objId})
}

func (m *IdSegmentModel) FindOneByID(ctx context.Context, id string) (*IdSegmentOrm, error) {
	var data IdSegmentOrm
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": objId}
	cacheKey := fmt.Sprintf("_id:%s", id)
	err = m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *IdSegmentModel) UpdateOneByTbName(ctx context.Context, tbName string, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data IdSegmentOrm
	filter["tb_name"] = tbName
	cacheKey := fmt.Sprintf(
		"tb_name:%s",
		tbName,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *IdSegmentModel) FindOneByTbName(ctx context.Context, tbName string) (*IdSegmentOrm, error) {
	var data IdSegmentOrm
	filter := bson.M{}
	filter["tb_name"] = tbName
	cacheKey := fmt.Sprintf(
		"tb_name:%s",
		tbName,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *IdSegmentModel) DeleteOneByTbName(ctx context.Context, tbName string) (*mongo.DeleteResult, error) {
	var data IdSegmentOrm
	filter := bson.M{}
	filter["tb_name"] = tbName
	cacheKey := fmt.Sprintf(
		"tb_name:%s",
		tbName,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}
